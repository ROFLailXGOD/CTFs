# TRICKY BIT (475 points)

> I always hated to be that last one, At least i should be in the second least place.

В архиве находим 2 файла — изображение [lsb1.bmp](./lsb1.bmp) и программу на Python — [Encrypt.py](./Encrypt.py).
Взглянем на картинку:

![](./lsb1.bmp)

Что же, похоже в ней что-то спрятано, ибо цвета сильно искажены. Описание задания и название файла намекают на технику
[Least Significant Bit (LSB)](https://www.boiteaklou.fr/Steganography-Least-Significant-Bit.html), но раз уж нам дали
саму программу, то имеет смысл изучить её. Полный листинг вы найдёте в репозитории, я же буду идти по порядку, в 
котором удобно понимать, что происходит, и буду пропускать незначительные вещи. Поехали!

```python
    def run(self, stega_text):
        self.text_to_hide = stega_text
        self.open_image()
        self.read_header()
```

Начало не очень интересно, тут функции делают то, что задумано. Размер заголовка указан как 54 байта, при этом после
считывания указатель на текущий байт перемещается. В итоге после чтения заголовка указатель стоит на 54-ом байте (при
нумерации с 0). Считанные байты напрямую переносятся в выходное изображение.

```python
self.hide_text_size()
self.do_steg(self.text_to_hide)
self.copy_rest()
self.close_file()

def hide_text_size(self):
    sz = len(self.text_to_hide)
    s_sz = str(sz)
    s_sz += DELIMITER
    self.do_steg(s_sz)
```

Тут уже интереснее. В выходное изображение заносится длина текста, который прячут, а затем некий разделитель в виде
символа `$`. После этого прячется сам текст. Далее никакой магии — переносится оставшаяся часть изображения, и файл
закрывается. Что же происходит в `do_steg()`?

```python
def do_steg(self, steg_text):

    for ch in range(0, len(steg_text)):  # итерируемся от 0 до длины текста

        current_char = steg_text[ch]  # берём текущий символ (с индексом ch)
        current_char_binary = '{0:08b}'.format(ord(current_char))  # записываем его в двоичном представлении

        for bit in range(0, len(current_char_binary)):  # итерируемся по битам текущего символа
            new_byte_binary = ''

            # берём текущий байт изображения и записываем его в двоичном представлении. Напомню, что начинаем мы с 
            # первого байта после заголовка
            current_image_binary = '{0:08b}'.format(ord(self.original_image[self.image_byte_counter]))

            new_byte_binary = current_image_binary[:7]  # берём первые СЕМЬ бит текущего пикселя

            new_byte_binary += current_char_binary[bit]  # и добавляем к ним 1 бит из текущего символа

            new_byte = chr(int(new_byte_binary, 2))  # собираем из этого новый байт (новый пиксель)

            self.new_image_data += new_byte  # переносим пиксель в изображение
            self.image_byte_counter += 1  # смещаем указатель на следующий байт
```

В принципе из комментариев всё должно быть ясно, но если кратко, то происходит следующее. Наше секретное сообщение
записывается в виде последовательности **бит**. Каждый бит последовательно вставляется в наименее значимую позицию
байта, отвечающего за пиксель картинки. Таким образом, для получения сообщения достаточно изучить байты выходного
изображения (сразу же после заголовка), вытащить из них наименее значимые биты и соединить их в байты. Напомню, что 
сообщение выглядит так:

```
[длина сообщения]$[сообщение]
``` 

Длину я вроде бы определил вручную проходом по байтам (я предположил, что сообщение не длинное, т.е. ± двухзначное, а
это всего лишь 16 байт + 8 байт для разделителя). Можно этот процесс и автоматизировать, но уже поздно. Далее я просто
реализовал описанный выше алгоритм прохода и склеил байты. На код можно взглянуть [тут](./tricky_bit.py). Запуск даёт:

```
37$DarkCTF{7H!5_0n3_was_4_l!ttl3_TRICKY}
```