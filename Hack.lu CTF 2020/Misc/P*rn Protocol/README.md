# P*rn Protocol (190 points, 90 solves)

>  know you want it. But please don't talk dirty to me.
>
> nc flu.xxx 2005 

В приложенном архиве находим [документацию](./Documentation.pdf) по этому протоколу. Если кратко, то существуют 
несколько типов сообщений, которыми можно обмениваться с сервером:

* Message ID
* Identifier
* Member ID
* Login
* Flag
* Error

Все они имеют следующую структуру:

<table>
  <tr>
    <td> Payload Length </td>
    <td> Payload Type </td>
  </tr>
  <tr>
    <td colspan="2" style="text-align:center"> Payload Data </td>
  </tr>
</table>

Также присутствуют ограничения:

1. Сервер может принять до 32 байт (включительно)
2. Первыми двумя сообщениями должны быть Message ID и Identifier
3. За раз можно отправить до 3-ёх сообщений
4. Количество обменов ограничено 4-мя

Далее идёт описание каждого типа сообщения, но я не буду вдаваться в подробности. Т.к. очевидно, что сообщений мы будем
отправлять немного, то я пошёл ленивым путём — подключаюсь к серверу, смотрю, что приходит. Вручную анализирую сообщения
от сервера и подготавливаю payload для отправки. Вновь подключаюсь, отправляю, получаю новый ответ и так далее
потихоньку продвигаюсь. По-хорошему, надо было бы реализовать нормальный протокол приёма/отправки сообщений, но я
посчитал, что так будет медленнее. В итоге путём своего метода я выявил алгоритм:

1. Подключаемся к серверу и получаем первое сообщение
2. Сохраняем identifier
3. Отправляем сообщения типа Message ID + Identifier + Member ID (для запроса логина и пароля)
4. Получаем второе сообщение и сохраняем из него логин и пароль
5. Отправляем сообщения типа Message ID + Identifier + Login. Нас попросят ввести логин (а затем пароль)
6. Передаём логин
7. Передаём пароль
8. Отправляем сообщения типа Message ID + Identifier + Flag
9. Забираем флаг

Реализацию можно посмотреть в [p*rn_protocol.py](./p*rn_protocol.py). Флаг:

```
flag{vpns_ar3_n0t_h4ck3r_appr0v3d}
```
